import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Row;
import org.apache.spark.sql.functions;
import org.apache.spark.sql.types.*;
import java.math.BigDecimal;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class CurrencyDecimalConverter {

    // Method to process dataset rows
    public static Dataset<Row> updateCurrencyDecimalPlaces(
            Dataset<Row> dataset,
            String currencyCodeField,
            Set<String> enumFieldNames) {

        // UDF to determine the decimal places for a currency
        dataset = dataset.withColumn(
                "currencyDecimalPlaces",
                functions.udf((String currencyCode) -> getCurrencyDecimalPlaces(currencyCode), DataTypes.IntegerType)
                        .apply(functions.col(currencyCodeField))
        );

        // Process each row in the dataset
        StructType schema = dataset.schema();
        for (StructField field : schema.fields()) {
            String fieldName = field.name();
            DataType fieldType = field.dataType();

            if (fieldType instanceof StructType) {
                // Handle nested structs recursively
                dataset = updateNestedStruct(dataset, fieldName, enumFieldNames, currencyCodeField);
            } else if (fieldType instanceof ArrayType) {
                // Handle arrays of data recursively
                dataset = dataset.withColumn(
                        fieldName,
                        functions.expr("transform(" + fieldName + ", x -> convertArrayField(x, currencyDecimalPlaces))")
                );
            } else if (fieldType == DoubleType.apply()) {
                // Check if the field matches enum and apply logic accordingly
                if (isEnumFieldNameMatching(fieldName, enumFieldNames)) {
                    dataset = dataset.withColumn(
                            fieldName,
                            functions.when(
                                    functions.col(fieldName).isNotNull(),
                                    functions.udf((Double value, Integer decimalPlaces) ->
                                                    convertToBigDecimalWithCurrency(value, decimalPlaces),
                                            DataTypes.createDecimalType()
                                    ).apply(functions.col(fieldName), functions.col("currencyDecimalPlaces"))
                            ).otherwise(functions.col(fieldName))
                    );
                } else {
                    // Convert non-enum double fields to BigDecimal
                    dataset = dataset.withColumn(
                            fieldName,
                            functions.udf((Double value) ->
                                            convertToBigDecimal(value),
                                    DataTypes.createDecimalType()
                            ).apply(functions.col(fieldName))
                    );
                }
            }
        }

        // Drop the temporary "currencyDecimalPlaces" column
        return dataset.drop("currencyDecimalPlaces");
    }

    // Handle nested structures
    private static Dataset<Row> updateNestedStruct(
            Dataset<Row> dataset,
            String structFieldName,
            Set<String> enumFieldNames,
            String currencyCodeField) {
        StructType structType = (StructType) dataset.schema().apply(structFieldName).dataType();

        for (StructField field : structType.fields()) {
            String nestedFieldName = structFieldName + "." + field.name();
            DataType fieldType = field.dataType();

            if (fieldType == DoubleType.apply()) {
                if (isEnumFieldNameMatching(field.name(), enumFieldNames)) {
                    dataset = dataset.withColumn(
                            nestedFieldName,
                            functions.when(
                                    functions.col(nestedFieldName).isNotNull(),
                                    functions.udf((Double value, Integer decimalPlaces) ->
                                                    convertToBigDecimalWithCurrency(value, decimalPlaces),
                                            DataTypes.createDecimalType()
                                    ).apply(functions.col(nestedFieldName), functions.col("currencyDecimalPlaces"))
                            ).otherwise(functions.col(nestedFieldName))
                    );
                } else {
                    dataset = dataset.withColumn(
                            nestedFieldName,
                            functions.udf((Double value) ->
                                            convertToBigDecimal(value),
                                    DataTypes.createDecimalType()
                            ).apply(functions.col(nestedFieldName))
                    );
                }
            }
        }

        return dataset;
    }

    // Check if a field name matches with an enum field
    private static boolean isEnumFieldNameMatching(String fieldName, Set<String> enumFieldNames) {
        // Check for both the original field name and the prefixed version
        String prefixedFieldName = "F_" + fieldName;
        String unprefixedFieldName = fieldName.startsWith("F_") ? fieldName.substring(2) : fieldName;
        return enumFieldNames.contains(fieldName) ||
               enumFieldNames.contains(prefixedFieldName) ||
               enumFieldNames.contains(unprefixedFieldName);
    }

    // Get currency decimal places using Java Currency class
    private static int getCurrencyDecimalPlaces(String currencyCode) {
        try {
            return java.util.Currency.getInstance(currencyCode).getDefaultFractionDigits();
        } catch (IllegalArgumentException e) {
            // Default to 2 decimal places if the currency code is invalid
            return 2;
        }
    }

    // Convert a double to BigDecimal with a default scale
    private static BigDecimal convertToBigDecimal(Double value) {
        if (value == null) return null;
        return BigDecimal.valueOf(value).setScale(2, BigDecimal.ROUND_HALF_UP);
    }

    // Convert a double to BigDecimal with currency-specific decimal places
    private static BigDecimal convertToBigDecimalWithCurrency(Double value, Integer decimalPlaces) {
        if (value == null || decimalPlaces == null) return null;
        return BigDecimal.valueOf(value).movePointLeft(decimalPlaces).setScale(decimalPlaces, BigDecimal.ROUND_HALF_UP);
    }
}
