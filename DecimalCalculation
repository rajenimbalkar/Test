import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Row;
import org.apache.spark.sql.Encoders;
import org.apache.spark.sql.types.*;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Currency;
import java.util.List;

public class DatasetConverter {

    /**
     * Converts all `Long` datatype fields in a dataset where each row is an array type into `BigDecimal`
     * and applies currency-based formatting for matched fields.
     *
     * @param dataset   The input dataset.
     * @param precision The precision of the `BigDecimal`.
     * @param scale     The scale of the `BigDecimal`.
     * @return Updated dataset with `Long` fields converted to `BigDecimal` and formatted per currency.
     */
    public static Dataset<Row> convertArrayRowsWithCurrencyLogic(Dataset<Row> dataset, int precision, int scale) {
        return dataset.map(row -> {
            List<Object> updatedRowArray = new ArrayList<>();

            // Extract the currency code from the header
            Row header = (Row) row.getAs("header"); // Adjust field name as necessary
            String currencyCode = header != null ? header.getAs("currencyCode") : "USD"; // Default to USD if missing

            // Process each element of the row array
            for (int i = 0; i < row.size(); i++) {
                Object element = row.get(i);

                if (element instanceof Row) {
                    // If the element is a Row (e.g., header or trailer), process it recursively
                    StructType elementSchema = (StructType) ((Row) element).schema();
                    updatedRowArray.add(convertRow((Row) element, elementSchema, precision, scale, currencyCode));
                } else if (element instanceof List) {
                    // If the element is a list (e.g., array of data rows), process each Row in the list
                    List<Row> dataArray = (List<Row>) element;
                    List<Row> updatedDataArray = new ArrayList<>();
                    for (Row dataRow : dataArray) {
                        StructType dataSchema = (StructType) dataRow.schema();
                        updatedDataArray.add(convertRow(dataRow, dataSchema, precision, scale, currencyCode));
                    }
                    updatedRowArray.add(updatedDataArray);
                } else {
                    // Leave other types unchanged
                    updatedRowArray.add(element);
                }
            }

            // Return the updated row as a new GenericRow
            return RowFactory.create(updatedRowArray.toArray());
        }, Encoders.row(dataset.schema()));
    }

    /**
     * Recursively converts all `Long` fields in a row to `BigDecimal` and applies currency-based formatting.
     *
     * @param row          The current row being processed.
     * @param schema       The schema of the row.
     * @param precision    The precision of the `BigDecimal`.
     * @param scale        The scale of the `BigDecimal`.
     * @param currencyCode The currency code for formatting.
     * @return A new row with updated fields.
     */
    private static Row convertRow(Row row, StructType schema, int precision, int scale, String currencyCode) {
        List<Object> updatedValues = new ArrayList<>();

        for (int i = 0; i < schema.fields().length; i++) {
            StructField field = schema.fields()[i];
            Object value = row.get(i);

            if (value instanceof Long) {
                BigDecimal bigDecimalValue = BigDecimal.valueOf((Long) value).setScale(scale, BigDecimal.ROUND_HALF_UP);

                // Check if the field matches an enum value or prefixed with F_
                if (AmountFields.matches(field.name())) {
                    int currencyDecimalPlaces = getCurrencyDecimalPlaces(currencyCode);
                    bigDecimalValue = bigDecimalValue.divide(BigDecimal.valueOf(Math.pow(10, currencyDecimalPlaces)), BigDecimal.ROUND_HALF_UP);
                }

                updatedValues.add(bigDecimalValue);
            } else if (value instanceof Row) {
                // Handle nested Row objects (e.g., nested structs)
                updatedValues.add(convertRow((Row) value, (StructType) field.dataType(), precision, scale, currencyCode));
            } else if (value instanceof List) {
                // Handle array of Rows
                List<Row> nestedRows = (List<Row>) value;
                List<Row> updatedRows = new ArrayList<>();
                for (Row nestedRow : nestedRows) {
                    updatedRows.add(convertRow(nestedRow, (StructType) field.dataType(), precision, scale, currencyCode));
                }
                updatedValues.add(updatedRows);
            } else {
                // Keep the original value for other data types
                updatedValues.add(value);
            }
        }

        // Construct a new Row with the updated values
        return new GenericRowWithSchema(updatedValues.toArray(), schema);
    }

    /**
     * Gets the decimal places for a given currency code using the Java Currency class.
     *
     * @param currencyCode The 3-character ISO currency code.
     * @return The number of decimal places for the currency.
     */
    private static int getCurrencyDecimalPlaces(String currencyCode) {
        try {
            Currency currency = Currency.getInstance(currencyCode);
            return currency.getDefaultFractionDigits();
        } catch (IllegalArgumentException e) {
            // Default to 2 decimal places if currency code is invalid
            return 2;
        }
    }

    /**
     * Enum representing fields that require currency-based logic.
     */
    public enum AmountFields {
        FIELD1, FIELD2, FIELD3; // Replace with actual field names

        /**
         * Checks if a field name matches the enum or is prefixed with F_ and matches the enum.
         *
         * @param fieldName The field name to check.
         * @return True if the field matches the enum, otherwise false.
         */
        public static boolean matches(String fieldName) {
            for (AmountFields field : AmountFields.values()) {
                if (field.name().equalsIgnoreCase(fieldName) || fieldName.startsWith("F_") && fieldName.substring(2).equalsIgnoreCase(field.name())) {
                    return true;
                }
            }
            return false;
        }
    }
}
