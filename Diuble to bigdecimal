The `DecimalType` variable in the `DynamicDoubleToDecimalConverter` class is defined to specify the precision and scale for converting `Double` values to `DecimalType`. However, the variable was not explicitly used in the transformation expressions, which might lead to some confusion. Instead, the conversion to `DecimalType` was done directly in the `transform` expressions as literals.

To clarify, letâ€™s refine the code to ensure that the `DecimalType` variable is utilized properly in the conversion logic. Here's how you can update the method to use the `DecimalType` variable correctly:

### Updated Main Class: `DynamicDoubleToDecimalConverter.java`

```java
import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Row;
import org.apache.spark.sql.types.*;
import org.apache.spark.sql.functions;

public class DynamicDoubleToDecimalConverter {

    /**
     * Method to convert Double fields within nested structures (header, trailer, and data) to DecimalType dynamically.
     *
     * @param df       The input Dataset<Row> containing nested structures.
     * @param precision The precision for DecimalType.
     * @param scale     The scale for DecimalType.
     * @return A new Dataset<Row> with Double fields converted to DecimalType.
     */
    public static Dataset<Row> convertDoubleFieldsToDecimal(Dataset<Row> df, int precision, int scale) {
        // Define the DecimalType with specified precision and scale
        DecimalType decimalType = new DecimalType(precision, scale);

        // Apply conversion for each nested structure dynamically
        Dataset<Row> convertedDf = df;

        for (String columnName : df.columns()) {
            // Get the data type of the column
            DataType columnType = df.schema().apply(columnName).dataType();
            if (columnType instanceof ArrayType) {
                // If the column is an array, check its element type
                ArrayType arrayType = (ArrayType) columnType;
                DataType elementType = arrayType.elementType();

                if (elementType instanceof StructType) {
                    // If the array contains structs, we need to transform each struct
                    convertedDf = convertedDf.withColumn(columnName, functions.expr(
                            "transform(" + columnName + ", element -> " +
                                    "struct(" + transformStructFields((StructType) elementType, decimalType) + "))"
                    ));
                }
            }
        }

        return convertedDf;
    }

    private static String transformStructFields(StructType structType, DecimalType decimalType) {
        StringBuilder sb = new StringBuilder();
        for (StructField field : structType.fields()) {
            String fieldName = field.name();
            DataType fieldType = field.dataType();

            if (fieldType instanceof DoubleType) {
                // If the field is of type Double, cast it to DecimalType
                sb.append("IF(typeof(element.").append(fieldName).append(") = 'double', CAST(element.").append(fieldName)
                        .append(" AS DECIMAL(").append(decimalType.precision()).append(", ").append(decimalType.scale()).append(")), element.")
                        .append(fieldName).append(") AS ").append(fieldName).append(", ");
            } else {
                // For other types, just include the field without modification
                sb.append("element.").append(fieldName).append(" AS ").append(fieldName).append(", ");
            }
        }

        // Remove the trailing comma and space
        return sb.substring(0, sb.length() - 2);
    }
}
```

### Key Changes and Usage of `DecimalType`

1. **`DecimalType` Initialization**: The `DecimalType` variable is created with the provided `precision` and `scale`.
2. **Usage in Transformations**: When constructing the transformation string in the `transformStructFields` method, we now utilize the properties of the `DecimalType` variable (`decimalType.precision()` and `decimalType.scale()`) to dynamically set the precision and scale in the SQL expression for casting.
3. **Ensures Correct Casting**: This makes it clear that the conversion is based on the `DecimalType` specified when calling the method.

### Updated Test Class: `DynamicDoubleToDecimalConverterTest.java`

The test class remains the same, as the logic being tested does not change. You can use the previous test class implementation to validate the changes made in the main class.

### Summary

By ensuring that the `DecimalType` variable is used in the transformation expressions, we create a clearer and more maintainable implementation that dynamically converts `Double` fields to `DecimalType` while allowing flexibility in defining precision and scale. This approach helps avoid hardcoding values and makes the code easier to understand and modify.
