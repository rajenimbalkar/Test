To use a `List` instead of an array for storing column information in the enum, you can modify the `TableMetadata` enum and the `SqlMergeGenerator` class accordingly. Hereâ€™s how to do it:

### Step-by-Step Implementation

1. **Define an Enum for Table Metadata with a Map of Lists:**
   - Store the table-specific metadata such as table name and columns to be inserted or updated in a map of lists.

2. **Update the Method to Generate the Merge SQL Statement:**
   - The method will retrieve the column information from the enum based on the provided table name.

### Example Enum and Method Implementation

#### Define the Enum

```java
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public enum TableMetadata {
    INSTANCE;

    private final Map<String, List<String>> tableColumnsMap;

    TableMetadata() {
        tableColumnsMap = new HashMap<>();
        tableColumnsMap.put("users", List.of("id", "name", "email"));
        tableColumnsMap.put("products", List.of("product_id", "product_name", "price"));
    }

    public List<String> getColumns(String tableName) {
        return tableColumnsMap.get(tableName);
    }

    public boolean hasTable(String tableName) {
        return tableColumnsMap.containsKey(tableName);
    }
}
```

#### Generate Merge SQL Method

```java
import java.util.List;
import java.util.StringJoiner;

public class SqlMergeGenerator {

    public static String generateMergeSql(String tableName) {
        if (!TableMetadata.INSTANCE.hasTable(tableName)) {
            throw new IllegalArgumentException("Table name not found in metadata: " + tableName);
        }

        List<String> columns = TableMetadata.INSTANCE.getColumns(tableName);

        StringJoiner columnJoiner = new StringJoiner(", ");
        StringJoiner valueJoiner = new StringJoiner(", ", "(", ")");
        StringJoiner updateJoiner = new StringJoiner(", ");
        StringJoiner conditionJoiner = new StringJoiner(" AND ");

        for (String column : columns) {
            columnJoiner.add(column);
            valueJoiner.add("?");
            updateJoiner.add(column + " = source." + column);
            conditionJoiner.add("target." + column + " = source." + column);
        }

        return "MERGE INTO " + tableName + " AS target " +
               "USING (VALUES " + valueJoiner + ") AS source (" + columnJoiner + ") " +
               "ON " + conditionJoiner + " " +
               "WHEN MATCHED THEN " +
               "UPDATE SET " + updateJoiner + " " +
               "WHEN NOT MATCHED THEN " +
               "INSERT (" + columnJoiner + ") " +
               "VALUES " + valueJoiner;
    }

    public static void main(String[] args) {
        String mergeSql = generateMergeSql("users");
        System.out.println(mergeSql);

        mergeSql = generateMergeSql("products");
        System.out.println(mergeSql);
    }
}
```

### Explanation

1. **Enum `TableMetadata`:**
   - Stores metadata for tables in a map where the key is the table name and the value is a list of column names.
   - Provides methods `getColumns` to retrieve columns for a given table name and `hasTable` to check if a table exists.

2. **Method `generateMergeSql`:**
   - Retrieves the column information from the `TableMetadata` enum based on the provided table name.
   - Constructs a SQL `MERGE` statement dynamically:
     - **Column Joiner:** Joins column names with a comma for the insert and update parts of the merge.
     - **Value Joiner:** Creates placeholders (`?`) for the values to be inserted.
     - **Update Joiner:** Constructs the `UPDATE SET` clause.
     - **Condition Joiner:** Constructs the `ON` condition for matching records using the same columns as the target values.

3. **Main Method:**
   - Demonstrates generating the `MERGE` SQL for the `users` and `products` tables defined in the `TableMetadata` enum.

### Running the Code

When you run the `main` method, it will print the dynamically generated `MERGE` SQL statements for the `users` and `products` tables:

```sql
MERGE INTO users AS target 
USING (VALUES (?, ?, ?)) AS source (id, name, email) 
ON target.id = source.id AND target.name = source.name AND target.email = source.email 
WHEN MATCHED THEN 
UPDATE SET id = source.id, name = source.name, email = source.email 
WHEN NOT MATCHED THEN 
INSERT (id, name, email) 
VALUES (?, ?, ?)

MERGE INTO products AS target 
USING (VALUES (?, ?, ?)) AS source (product_id, product_name, price) 
ON target.product_id = source.product_id AND target.product_name = source.product_name AND target.price = source.price 
WHEN MATCHED THEN 
UPDATE SET product_id = source.product_id, product_name = source.product_name, price = source.price 
WHEN NOT MATCHED THEN 
INSERT (product_id, product_name, price) 
VALUES (?, ?, ?)
```

This implementation ensures that you can dynamically generate `MERGE` SQL statements based on table names and their corresponding columns, making it flexible and easily extendable.
